#!/usr/bin/env python
from fileinput import close
from socket import timeout
from PyQt5 import QtWidgets, QtCore, QtGui, uic
import pyqtgraph as pg
from pyqtgraph import PlotWidget

from argparse import ArgumentParser
import sys, os
import numpy as np
from pathlib import Path
import time

import reuss as rs
from slsdet import Detector, runStatus, detectorSettings, timingMode

class MainWindow(QtWidgets.QMainWindow):

    def __init__(self, *args, **kwargs):
        self.last_progress = 0
        pg.setConfigOption('background', (247, 247, 247))
        pg.setConfigOption('foreground', 'k')
        
        #Load UI file as main Window
        super(MainWindow, self).__init__()
        self.det = Detector()
        uic.loadUi('g2panel.ui', self)
        self.check_powerchip()
        
        pen = pg.mkPen(color = (36, 119, 173), width=1) 
        #Plotting the data
        self.curve = self.plotWidget.plot(pen=pen)

        #Plotting second plot for gain bit
        self.p1 = self.gamBitPlotWidget.plot(pen=pen)

        self.addPlot()
        self.rcv = rs.Receiver(args[0].receiver_endpoint)
        self.rcv.udp_source = f"{self.det.udp_dstip}:{self.det.udp_dstport}"
        
        self.rcv.fpath = Path("/home/l_msdetect/erik/tmp/g2")
        preview_endpoint = args[0].receiver_endpoint.rsplit(':', 1)[0]+':4547'
        self.zmq_rcv = rs.PreviewReceiver(preview_endpoint, timeout_ms=100)
        self.zmq_rcv.start()

        #Getting data from detectors
        self.update_fields()
        #Initializing from the detector to disable frames or trigger according to timing modes
        if self.det.timing == timingMode.AUTO_TIMING:
            self.triggerSpinBox.setDisabled(True)
        if self.det.timing == timingMode.TRIGGER_EXPOSURE:
            self.frameSpinBox.setDisabled(True)

        #For simple attributes it is possible to connect directly using a lambda 
        # do avoid having to make an extra function
        self.highVoltageSpinBox.editingFinished.connect(self.setHighVolatge)

        #Needs a function since editingFinished doesn't pass a parameter
        self.nameLineEdit.editingFinished.connect(self.setFname)
        self.pathLineEdit.editingFinished.connect(self.setPath)

        #Enabling the file write options when yes button is clicked
        self.yesRadioButton.toggled.connect(lambda x: setattr(self.rcv, 'fwrite', x))

        #Exposure time should be set on both unit and value change
        self.expTimeComboBox.currentIndexChanged.connect(self.setExptime)
        self.exposureSpinBox.editingFinished.connect(self.setExptime)

        #Setting Period to detector and time unit
        self.periodTimeComboBox.currentIndexChanged.connect(self.setPeriod)
        self.periodSpinBox.editingFinished.connect(self.setPeriod)

        #Setting frames to detector after completion of editing
        self.frameSpinBox.editingFinished.connect(self.setFrames)

        #Setting trigger to detector and time unit
        self.triggerSpinBox.editingFinished.connect(self.setTrigger)

        #Setting timing modes
        self.autoRadioButton.clicked.connect(self.autoMode)
        self.triggerRadioButton.clicked.connect(self.triggerMode)

        #setting gain
        self.dynamicRadioButton.clicked.connect(self.dynamicGain)
        self.g1RadioButton.clicked.connect(self.fixedG1Gain)
        self.g2RadioButton.clicked.connect(self.fixedG2Gain)

        #Setting Delay after Trigger to detector and time unit
        self.triggerTimeComboBox.currentIndexChanged.connect(self.setDelayTrigger)
        self.delayTriggerSpinBox.editingFinished.connect(self.setDelayTrigger)

        #Setting and getting index values
        self.indexSpinBox.editingFinished.connect(self.setIndex)

        #Function for start button
        self.startButton.clicked.connect(self.start)

        #Connecting stop button to stop function
        self.stopButton.clicked.connect(self.stopProcess)

        #Plot related settings
        #using a validator to make sure we have an integer, then set the streaming
        #frequency of the preview
        validator = QtGui.QIntValidator() 
        validator.setRange(1, 100000)
        self.refreshRateLineEdit.setValidator(validator) 
        self.refreshRateLineEdit.editingFinished.connect(self.setStreamNth)

        #setting the axis values with the updates and adding validations for the integer input only
        self.xMinLineEdit.setValidator(validator)
        self.xMinLineEdit.editingFinished.connect(self.addPlot)
        self.xMaxLineEdit.setValidator(validator)
        self.xMaxLineEdit.editingFinished.connect(self.addPlot)

        #Allowing for negetive values in Ymin for pedestal correction
        validation = QtGui.QIntValidator()
        validation.setRange(-100000, 100000)
        self.yMinLineEdit.setValidator(validation)
        self.yMinLineEdit.editingFinished.connect(self.addPlot)
        self.xMaxLineEdit.setValidator(validator)
        self.yMaxLineEdit.editingFinished.connect(self.addPlot)

        #Power off button
        self.closeButton.clicked.connect(self.powerOffDetector)

        #Pedestal correction 
        self.pedestalCheckBox.stateChanged.connect(lambda x: setattr(self.zmq_rcv, 'collect_pedestal', x))
        
        #Timers
        #Timer to update the progress bar
        self.progress_timer = QtCore.QTimer()
        self.progress_timer.timeout.connect(self.update_progress)
        self.update_progress()

        #Timer to update the plots
        self.plot_timer =  QtCore.QTimer()
        self.plot_timer.timeout.connect(self.update_plot)

        #mask
        self.actionLoadMask.triggered.connect(self.load_mask)
        self.maskCheckBox.stateChanged.connect(lambda x: setattr(self.zmq_rcv, 'mask_channels', x))

        #help
        self.actionAbout.triggered.connect(self.show_about)

    def check_powerchip(self):
        if self.det.powerchip == True:
            pass
        else:
            msg = QtWidgets.QMessageBox()
            msg.setWindowTitle("Chip Powered Off!!!")
            msg.setText("The chip is powered off. Please power on the Chip and run the program.\n Thank You")
            msg.setIcon(QtWidgets.QMessageBox.Critical)
            x = msg.exec_()
            exit()
            
    #to add plot and update it according to the values from GUI
    def addPlot(self):
        #Getting the intial axis value set from ui
        Xmin = int(self.xMinLineEdit.text())
        Xmax = int(self.xMaxLineEdit.text())
        Ymin = int(self.yMinLineEdit.text())
        Ymax = int(self.yMaxLineEdit.text())

        #adding labels for the plots
        self.plotWidget.setLabel('left',"<span style=\"color:black;font-size:14px\">Output [ADC]</span>")
        self.plotWidget.setLabel('bottom',"<span style=\"color:black;font-size:14px\">Channel [#]</span>")
        #setting the max and  min axis values
        self.plotWidget.setXRange(Xmin, Xmax, padding=0.01)
        self.plotWidget.setYRange(Ymin, Ymax, padding=0.01)

        self.gamBitPlotWidget.setLabel('left',"<span style=\"color:black;font-size:14px\">Gain Bit</span>")
        self.gamBitPlotWidget.setLabel('bottom',"<span style=\"color:black;font-size:14px\">Channel [#]</span>")
        self.gamBitPlotWidget.setXRange(Xmin, Xmax, padding=0.01)
        self.gamBitPlotWidget.setYRange(0, 2, padding=0.05)

    def show_about(self):
        msg = QtWidgets.QMessageBox()
        msg.setWindowTitle("Gotthard2 GUI")
        msg.setText("Credits:\n Sudip Shrestha\n Dhanya Thattil\n Erik Frojdh")
        x = msg.exec_()

    #Load mask file from pc
    def load_mask(self):
        response = QtWidgets.QFileDialog.getOpenFileName(
            parent=self,
            caption='Select a mask file',
            directory=os.getcwd(),
            # filter=file_filter,
            # initialFilter='Excel File (*.xlsx *.xls)'
        )
        if (response[0]):
            self.zmq_rcv.load_mask(response[0])

    #updating values from detector to GUI
    def update_fields(self):
        """Update all fields in the GUI with current values from the detector"""
        self.triggerSpinBox.setValue(self.det.triggers)
        self.indexSpinBox.setValue(self.rcv.findex)
        self.highVoltageSpinBox.setValue(self.det.highvoltage)
        self.frameSpinBox.setValue(self.det.frames)
        self.nameLineEdit.setText(self.rcv.fname)
        self.pathLineEdit.setText(self.rcv.fpath)

        self.update_status()
        
        if self.det.timing == timingMode.AUTO_TIMING:
            self.rcv.frames = self.det.frames
        elif self.det.timing == timingMode.TRIGGER_EXPOSURE:
            self.rcv.frames = self.det.triggers
        else:
            raise ValueError("Unsupported timing setting")

        #converting to righ unit of time
        tExp = (self.det.exptime)
        #Checking if the time is in nano seconds as python uses seconds
        if tExp < 100e-9:
            #Setting units in nano seconds
            self.expTimeComboBox.setCurrentIndex(2)
            #converting it to nano seconds
            exposuretime = (tExp / 1e-9)
            self.exposureSpinBox.setValue(exposuretime)
        elif tExp < 100e-6:
            #Setting units in micro seconds
            self.expTimeComboBox.setCurrentIndex(1)
            #Converting the seconds value to micro seconds
            exposuretime1 = (tExp / 1e-6)
            self.exposureSpinBox.setValue(exposuretime1)
        else:
            #Setting units in miliseconds
            self.expTimeComboBox.setCurrentIndex(0)
            #Converting the second values to miliseconds
            exposuretime0 = (tExp / 1e-3)
            self.exposureSpinBox.setValue(exposuretime0)

        #Converting to right time unit for period
        tPeriod = self.det.period
        if tPeriod < 100e-9:
            self.periodTimeComboBox.setCurrentIndex(2)
            periodTime = (tPeriod/1e-9)
            self.periodSpinBox.setValue(periodTime)
        elif tPeriod < 100e-6:
            self.periodTimeComboBox.setCurrentIndex(1)
            periodTime1 = (tPeriod/1e-6)
            self.periodSpinBox.setValue(periodTime1)
        else:
            self.periodTimeComboBox.setCurrentIndex(0)
            periodTime0 = (tPeriod/1e-3)
            self.periodSpinBox.setValue(periodTime0)

        #Converting to right time unit for period
        tDelay = self.det.delay
        if tDelay < 100e-9:
            self.triggerTimeComboBox.setCurrentIndex(2)
            delayTime = (tDelay/1e-9)
            self.delayTriggerSpinBox.setValue(delayTime)
        elif tDelay < 100e-6:
            self.triggerTimeComboBox.setCurrentIndex(1)
            delayTime1 = (tDelay/1e-6)
            self.delayTriggerSpinBox.setValue(delayTime1)
        else:
            self.triggerTimeComboBox.setCurrentIndex(0)
            delayTime0 = (tDelay/1e-3)
            self.delayTriggerSpinBox.setValue(delayTime0)

        #TODO check logic? 
        #Setting the save file radio buttons from the receiver.
        self.noRadioButton.setChecked(not self.rcv.fwrite)

        #adding condition to hide the file saving options when the writing option is false
        if self.rcv.fwrite == False:
            self.widget.hide()
        #Updating the referech rater of the stream from the receiver
        self.refreshRateLineEdit.setText(str(self.rcv.stream_nth))
        
        #Updating the gain setting from detector to the GUI
        match self.det.settings:
            case detectorSettings.DYNAMICGAIN:
                self.dynamicRadioButton.setChecked(True)
            case detectorSettings.FIXGAIN1:
                self.g1RadioButton.setChecked(True)
            case detectorSettings.FIXGAIN2:
                self.g2RadioButton.setChecked(True)

        #Updating the timing mode from detector to the GUI
        match self.det.timing:
            case timingMode.AUTO_TIMING:
                self.autoRadioButton.setChecked(True)
            case timingMode.TRIGGER_EXPOSURE:
                self.triggerRadioButton.setChecked(True)


    def update_progress(self):

        #Get progress and set as int in %
        progress_d = self.rcv.progress*100
        p_int = int(progress_d)
        self.progressBar.setValue(p_int)

        if progress_d == self.last_progress and p_int!=0:
            if self.det.status == runStatus.IDLE:
                time.sleep(1)
                print("Issuing stop!")
                self.progress_timer.stop()
                self.plot_timer.stop()
                self.rcv.stop()

        if p_int == 100:
            self.progress_timer.stop()
            self.plot_timer.stop()
            while not self.rcv.done:
                time.sleep(0.1)
            self.rcv.stop()
            #Hiding the stop button after acquistion completion
            self.stopButton.hide()
            #Showing start button to start new acquistion after completing one acquistion
            self.startButton.show()
        self.last_progress = progress_d
        self.update_status()

    #Updating the status of the detector
    def update_status(self):
        s = str(self.det.status).split('.')[1]
        self.statusLabel.setText(s)

    #Function to update the plot
    def update_plot(self):
        data, gain = self.zmq_rcv.get_data()
        self.curve.setData(data)
        self.p1.setData(gain)

    #To start the acquire process
    def start(self):
        self.progress_timer.start(100)
        self.plot_timer.start(50)
        self.rcv.start()
        time.sleep(0.1)
        self.det.start()
    
    #Stop the process
    def stopProcess(self):
        #Stops the detector from acquistion proces
        self.det.stop()

    #Setting intial file path
    def setPath(self):
        self.rcv.fpath = self.pathLineEdit.text()

    #Setting initial file name
    def setFname(self):
        self.rcv.fname = self.nameLineEdit.text()
    
    #Setting initial frames
    def setFrames(self):
        #If trigger mode is selected then the frame number is replaced by the triggers other wise it takes the frame number
        if self.det.timing==timingMode.TRIGGER_EXPOSURE:
            pass
        #number of frames needs to go to both receiver and detector
        else:
            self.rcv.frames = self.frameSpinBox.value()
            self.det.frames = self.frameSpinBox.value()

    #Setting initial trigger
    def setTrigger(self):
        #If trigger mode is selected then the frame number is replaced by the triggers other wise it takes the frame number
        if self.det.timing==timingMode.TRIGGER_EXPOSURE:
            self.rcv.frames = self.triggerSpinBox.value()
            self.det.triggers = self.triggerSpinBox.value()
        #number of frames needs to go to both receiver and detector
        else:
        #number of frames needs to go to both receiver and detector
            self.det.triggers = self.triggerSpinBox.value()

    #setting and updating high voltage
    def setHighVolatge(self):
        self.det.highvoltage = self.highVoltageSpinBox.value()

    #updating index values
    def setIndex(self):
        self.rcv.findex = self.indexSpinBox.value()

    #Function for setting exposure time and time unit
    def setExptime(self):
        match self.expTimeComboBox.currentIndex():
            case 0:
                unit = 1e-3
            case 1:
                unit = 1e-6
            case 2:
                unit = 1e-9
        #Converting the input values right unit of time
        self.det.exptime = self.exposureSpinBox.value()*unit

    #Function for setting period time and time unit
    def setPeriod(self):
        match self.periodTimeComboBox.currentIndex():
            case 0:
                unit = 1e-3
            case 1:
                unit = 1e-6
            case 2:
                unit = 1e-9
        self.det.period = self.periodSpinBox.value()*unit

    #Function for setting Delay after Trigger time and time unit
    def setDelayTrigger(self):
        match self.triggerTimeComboBox.currentIndex():
            case 0:
                unit = 1e-3
            case 1:
                unit = 1e-6
            case 2:
                unit = 1e-9
        self.det.delay = self.delayTriggerSpinBox.value()*unit

    #Setting Gain modes
    def dynamicGain(self, selected):
        if selected:
            self.det.settings = detectorSettings.DYNAMICGAIN
    
    def fixedG1Gain(self, selected):
        if selected:
            self.det.settings = detectorSettings.FIXGAIN1

    def fixedG2Gain(self, selected):
        if selected:
            self.det.settings = detectorSettings.FIXGAIN2

   #Setting timing  modes
    def autoMode(self, selected):
        if selected:
            self.det.timing = timingMode.AUTO_TIMING
            self.rcv.frames = self.det.frames
            self.frameSpinBox.setDisabled(False)
            self.triggerSpinBox.setDisabled(True)

    def triggerMode(self, selected):
        if selected:
            self.det.timing = timingMode.TRIGGER_EXPOSURE
            self.rcv.frames = self.det.triggers
            self.frameSpinBox.setDisabled(True)
            self.triggerSpinBox.setDisabled(False)
        
    #Safely powering off the detectors
    def powerOffDetector(self):
        #Asking user if they really want to power off the detectors
        powerDlg = QtWidgets.QMessageBox()
        powerDlg.setWindowTitle("Power Off the Detector!!!")
        powerDlg.setText("Do you really want to power off the Detector?")
        powerDlg.setStandardButtons(powerDlg.Yes | powerDlg.Cancel)
        powerDlg.setIcon(QtWidgets.QMessageBox.Warning)
        button = powerDlg.exec()
        #Powering of detector safely only fater pressing yes button
        if button == powerDlg.Yes:
            self.det.highvoltage = 0
            self.highVoltageSpinBox.setValue(self.det.highvoltage)
            #Wait 1 sec after lowering the voltage 
            time.sleep(1)
            #Power off chip
            self.det.powerchip = False
            self.close()

    #Setting the referesh rate from the receiver
    def setStreamNth(self):
        self.rcv.stream_nth = int(self.refreshRateLineEdit.text())


if __name__ == '__main__':
    
    parser = ArgumentParser()
    parser.add_argument(
        "receiver_endpoint", 
        help="Zmq endpoint to connect to the receiver", 
        default = 'tcp://127.0.0.1:5556',
        nargs = '?',
        type=str,
    )
    args = parser.parse_args()
    app = QtWidgets.QApplication(sys.argv)

    main = MainWindow(args)
    main.show()

    # # #Timer for updating the plot
    # timer = QtCore.QTimer()
    # timer.timeout.connect(main.update_status)
    # timer.start(100)
    
    #Run the app
    app.exec_()

    #Stop the receiving process before exiting
    main.zmq_rcv.stop()

