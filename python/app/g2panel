#!/usr/bin/env python
from PyQt5 import QtWidgets, QtCore, QtGui, uic
import pyqtgraph as pg
from pyqtgraph import PlotWidget

from argparse import ArgumentParser
import sys
import numpy as np
from pathlib import Path
import time

import reuss as rs
from slsdet import Detector, runStatus

class MainWindow(QtWidgets.QMainWindow):

    def __init__(self, *args, **kwargs):

        self.last_progress = 0
        pg.setConfigOption('background', (247, 247, 247))
        pg.setConfigOption('foreground', 'k')
        

        print(args)

        #Load UI file as main Window
        super(MainWindow, self).__init__()
        uic.loadUi('g2panel.ui', self)
        
        
        self.addPlot()

        if args[0].demo:
            self.det = rs.DummyDetector()
            self.rcv = rs.DummyReceiver(args[0].receiver_endpoint)
            self.zmq_rcv = rs.DummyPreviewReceiver('tcp://129.129.202.97:4547')
            self.zmq_rcv.start()
            self.zmq_rcv.mask[100:200] = True

        else:
            from slsdet import Detector, runStatus
            self.det = Detector()
            self.rcv = rs.Receiver(args[0].receiver_endpoint)
            self.rcv.udp_source = f"{self.det.udp_dstip}:{self.det.udp_dstport}"
            self.rcv.frames = self.det.frames
            self.rcv.fpath = Path("/home/l_msdetect/erik/tmp/g2")
            self.zmq_rcv = rs.PreviewReceiver('tcp://127.0.0.1:4547', timeout_ms=100)
            self.zmq_rcv.start()


        self.update_fields()

        #Function for start button
        self.startButton.clicked.connect(self.start)
    
        #For simple attributes it is possible to connect directly using a lambda 
        # do avoid having to make an extra function
        self.highVoltageSpinBox.editingFinished.connect(self.setHighVolatge)

        #Needs a function since editingFinished doesn't pass a parameter
        self.nameLineEdit.editingFinished.connect(self.setFname)
        self.pathLineEdit.editingFinished.connect(self.setPath)

        #Enabling the file write options when yes button is clicked
        self.yesRadioButton.toggled.connect(lambda x: setattr(self.rcv, 'fwrite', x))

        #Exposure time should be set on both unit and value change
        self.expTimeComboBox.currentIndexChanged.connect(self.setExptime)
        self.exposureSpinBox.editingFinished.connect(self.setExptime)

        #Setting Period to detector and time unit
        self.periodTimeComboBox.currentIndexChanged.connect(self.setPeriod)
        self.periodSpinBox.editingFinished.connect(self.setPeriod)

        #Setting frames to detector after completion of editing
        self.frameSpinBox.editingFinished.connect(self.setFrames)

        #Setting trigger to detector and time unit
        self.triggerSpinBox.editingFinished.connect(self.setTrigger)

        #Setting timing modes
        self.autoRadioButton.clicked.connect(self.autoMode)
        self.triggerRadioButton.clicked.connect(self.triggerMode)

        #setting gain
        self.dynamicRadioButton.clicked.connect(self.dynamicGain)
        self.g1RadioButton.clicked.connect(self.fixedG1Gain)
        self.g2RadioButton.clicked.connect(self.fixedG2Gain)

        #Setting Delay after Trigger to detector and time unit
        self.triggerTimeComboBox.currentIndexChanged.connect(self.setDelayTrigger)
        self.delayTriggerSpinBox.editingFinished.connect(self.setDelayTrigger)

        #Setting and getting index values
        self.indexSpinBox.editingFinished.connect(self.setIndex)

        #Plot related settings

        #using a validator to make sure we have an integer, then set the streaming
        #frequency of the preview
        validator = QtGui.QIntValidator() 
        validator.setRange( 1, 100000)
        self.refreshRateLineEdit.setValidator(validator) 
        self.refreshRateLineEdit.editingFinished.connect(self.setStreamNth)


        #setting the axis values with the updates and adding validations for the integer input only
        self.xMinLineEdit.setValidator(validator)
        self.xMinLineEdit.editingFinished.connect(self.addPlot)
        self.xMaxLineEdit.setValidator(validator)
        self.xMaxLineEdit.editingFinished.connect(self.addPlot)
        self.yMinLineEdit.setValidator(validator)
        self.yMinLineEdit.editingFinished.connect(self.addPlot)
        self.xMaxLineEdit.setValidator(validator)
        self.yMaxLineEdit.editingFinished.connect(self.addPlot)

        #Power off button
        self.closeButton.clicked.connect(self.powerOffDetector)


        #Pedestal correction 
        self.pedestalCheckBox.stateChanged.connect(lambda x: setattr(self.zmq_rcv, 'collect_pedestal', x))

        #Timers
        #Timer to update the progress bar
        self.progress_timer = QtCore.QTimer()
        self.progress_timer.timeout.connect(self.update_progress)
        self.update_progress()

        #Timer to update the plots
        self.plot_timer =  QtCore.QTimer()
        self.plot_timer.timeout.connect(self.update_plot)


        #help
        self.actionAbout.triggered.connect(self.show_about)

    #to add plot and update it according to the values from GUI
    def addPlot(self):
        #Getting the intial axis value set from ui
        Xmin = int(self.xMinLineEdit.text())
        Xmax = int(self.xMaxLineEdit.text())
        Ymin = int(self.yMinLineEdit.text())
        Ymax = int(self.yMaxLineEdit.text())


        pen = pg.mkPen(color = (36, 119, 173), width=1) 
        #Plotting the data
        self.curve = self.plotWidget.plot(pen=pen)
        #adding labels for the plots
        self.plotWidget.setLabel('left',"<span style=\"color:black;font-size:14px\">Output [ADC]</span>")
        self.plotWidget.setLabel('bottom',"<span style=\"color:black;font-size:14px\">Channel [#]</span>")
        #setting the max and  min axis values
        self.plotWidget.setXRange(Xmin, Xmax, padding=0.01)
        self.plotWidget.setYRange(Ymin, Ymax, padding=0.01)

        #Plotting second plot for gain bit
        self.p1 = self.gamBitPlotWidget.plot(pen=pen)
        self.gamBitPlotWidget.setLabel('left',"<span style=\"color:black;font-size:14px\">Gain Bit</span>")
        self.gamBitPlotWidget.setLabel('bottom',"<span style=\"color:black;font-size:14px\">Channel [#]</span>")
        self.gamBitPlotWidget.setXRange(Xmin, Xmax, padding=0.01)
        self.gamBitPlotWidget.setYRange(0, 2, padding=0.05)


    def show_about(self):
        msg = QtWidgets.QMessageBox()
        msg.setWindowTitle("Gotthard2 GUI")
        msg.setText("Credits:\n Sudip Shrestha\n Dhanya Thattil\n Erik Froejdh")
        x = msg.exec_()

    #updating values from detector to GUI
    def update_fields(self):
        """Update all fields in the GUI with current values from the detector"""
        self.frameSpinBox.setValue(self.det.frames)
        self.nameLineEdit.setText(self.rcv.fname)
        self.pathLineEdit.setText(self.rcv.fpath)
        self.exposureSpinBox.setValue(self.det.exptime)
        self.periodSpinBox.setValue(self.det.period)
        self.triggerSpinBox.setValue(self.det.trigger)
        self.delayTriggerSpinBox.setValue(self.det.delayTrigger)
        self.indexSpinBox.setValue(self.rcv.findex)

        #TODO check logic? 
        #Setting the save file radio buttons from the receiver.
        self.noRadioButton.setChecked(not self.rcv.fwrite)

        #adding condition to hide the file saving options when the writing option is false
        if self.rcv.fwrite == False:
            self.widget.hide()
        #Updating the referech rater of the stream from the receiver
        self.refreshRateLineEdit.setText(str(self.rcv.stream_nth))


        #TODO! Add the additional fields


    def update_progress(self):

        progress_d = self.rcv.progress*100
        p_int = int(progress_d)

        self.progressBar.setValue(p_int)
        pc = 0
        if progress_d == self.last_progress and p_int!=0:
            print(progress_d, self.last_progress)
            if self.det.status == runStatus.IDLE:
                time.sleep(1)
                self.progress_timer.stop()
                self.plot_timer.stop()
                self.rcv.stop()

        if p_int == 100:
            self.progress_timer.stop()
            self.plot_timer.stop()

        self.last_progress = progress_d

    #Updating the status of the detector
    def update_status(self):
        s = str(self.det.status).split('.')[1]
        self.statusLabel.setText(s)

    #Function to update the plot
    def update_plot(self):
        data = self.zmq_rcv.get_data()
        self.curve.setData(data)
        self.p1.setData(data)

    #To start the acquire process
    def start(self):
        self.progress_timer.start(100)
        self.plot_timer.start(50)
        self.rcv.start()
        time.sleep(0.1)
        self.det.start()

    #Setting intial file path
    def setPath(self):
        self.rcv.fpath = self.pathLineEdit.text()

    #Setting initial file name
    def setFname(self):
        self.rcv.fname = self.nameLineEdit.text()
    
    #Setting initial frames
    def setFrames(self):
        #number of frames needs to go to both receiver and detector
        self.rcv.frames = self.frameSpinBox.value()
        self.det.frames = self.frameSpinBox.value()

    #Setting initial trigger
    def setTrigger(self):
        #number of frames needs to go to both receiver and detector
        self.det.trigger = self.triggerSpinBox.value()

    #setting and updating high voltage
    def setHighVolatge(self):
        self.det.highvoltage = self.highVoltageSpinBox.value()

    #updating index values
    def setIndex(self):
        self.rcv.findex = self.indexSpinBox.value()


    #Function for setting exposure time and time unit
    def setExptime(self):
        match self.expTimeComboBox.currentIndex():
            case 0:
                unit = 1e-3
            case 1:
                unit = 1e-6
            case 2:
                unit = 1e-9
        self.det.exptime = self.exposureSpinBox.value()*unit

    #Function for setting period time and time unit
    def setPeriod(self):
        match self.periodTimeComboBox.currentIndex():
            case 0:
                unit = 1e-3
            case 1:
                unit = 1e-6
            case 2:
                unit = 1e-9
        self.det.period = self.periodSpinBox.value()*unit

    #Function for setting Delay after Trigger time and time unit
    def setDelayTrigger(self):
        match self.triggerTimeComboBox.currentIndex():
            case 0:
                unit = 1e-3
            case 1:
                unit = 1e-6
            case 2:
                unit = 1e-9
        self.det.delayTrigger = self.delayTriggerSpinBox.value()*unit

    #Setting Gain modes
    def dynamicGain(self, selected):
        if selected:
            print('Dynamic')
    
    def fixedG1Gain(self, selected):
        if selected:
            print('fixed G1')

    def fixedG2Gain(self, selected):
        if selected:
            print('fixed G2')  

   #Setting timing  modes
    def autoMode(self, selected):
        if selected:
            print('Auto timing mode')
    
    def triggerMode(self, selected):
        if selected:
            print('Trigger timing mode')

    #Safely powering off the detectors
    def powerOffDetector(self):
        self.det.highvoltage = 0.0
        self.highVoltageSpinBox.setValue(self.det.highvoltage)

    #Setting the referesh rate from the receiver
    def setStreamNth(self):
        self.rcv.stream_nth = int(self.refreshRateLineEdit.text())

if __name__ == '__main__':


    parser = ArgumentParser()
    parser.add_argument(
        "receiver_endpoint", 
        help="Zmq endpoint to connect to the receiver", 
        type=str,
    )
    parser.add_argument(
        "-d", "--demo", 
        help="Demo mode, doesn't require detector", 
        action='store_true'
    )

    args = parser.parse_args()
    app = QtWidgets.QApplication(sys.argv)
    main = MainWindow(args)
    main.show()

    #Timer for updating the plot
    timer = QtCore.QTimer()
    timer.timeout.connect(main.update_status)
    timer.start(100)
    

    #Run the app
    app.exec_()

    # #Stop the receiving process before exiting
    main.zmq_rcv.stop()

