#!/usr/bin/env python
import numpy as np
import ctypes
import multiprocessing as mp

import zmq
import pyqtgraph as pg
from pyqtgraph.Qt import QtCore, QtGui, QtWidgets
from pyqtgraph.dockarea import *


import argparse


pg.setConfigOptions(imageAxisOrder='row-major')
pg.mkQApp()

app = pg.mkQApp("DockArea Example")
# win = QtGui.QMainWindow()
win = QtWidgets.QMainWindow()
win.setWindowTitle('Jungfrau')
area = DockArea()
win.setCentralWidget(area)
win.resize(1000,500)
d1 = Dock("Image", size=(1000, 250))
# d2 = Dock("Gain", size=(1000,250))
area.addDock(d1, 'top')     ## place d2 at right edge of dock area
# area.addDock(d2, 'bottom', d1)## place d3 at bottom edge of d1

w1 = pg.GraphicsLayoutWidget()
p1 = w1.addPlot(title="")
d1.addWidget(w1)
img = pg.ImageItem()
p1.addItem(img)
hist = pg.HistogramLUTItem()
hist.setImageItem(img)
hist.gradient.loadPreset('viridis')
w1.addItem(hist)

charge = np.random.normal(size = 300)
w2 = pg.GraphicsLayoutWidget()
# d2.addWidget(w2)

img2 = pg.ImageItem()
p2 = w2.addPlot()
p2.addItem(img2)
hist2 = pg.HistogramLUTItem()
hist2.setImageItem(img2)
hist2.gradient.loadPreset('viridis')
w2.addItem(hist2)


# curve2 = p2.plot()



nrow = 512
ncol = 1024

#Some initial data
data = np.random.rand(nrow,ncol)
img.setImage(data, autoRange = False, autoLevels = False, autoHistogramRange = False)

win.resize(900, 800)
win.show()

p1.setAspectLocked(True)
p2.setAspectLocked(True)
hist.setLevels(0,255)
hist2.setLevels(0,3)
ip = "127.0.0.1"
port = 4545


dt = np.float32

class PyZmqReceiver:
    def __init__(self, endpoint, timeout_ms = 100):
        self.context = zmq.Context()
        self.socket = self.context.socket(zmq.SUB)
        self.socket.setsockopt(zmq.RCVTIMEO, timeout_ms)
        self.socket.connect(endpoint)
        self.socket.setsockopt(zmq.SUBSCRIBE, b"")
    
    def read_frame(self):
        msgs = self.socket.recv_multipart()
        frame_nr = np.frombuffer(msgs[0], dtype = np.int64)[0]
        image = np.frombuffer(msgs[1], dtype = np.float32).reshape(512, 1024)
        return frame_nr, image

def read_stream(buffer, exit_flag):
    """Read images from the receiver zmq stream"""
    zmq_receiver = PyZmqReceiver(f'tcp://{ip}:{port}', timeout_ms = 100)


    while not exit_flag.value:
        #Try to read an image, if timeout then try again
        try:
            frame_nr, tmp = zmq_receiver.read_frame()
            with buffer.get_lock():
                image = np.frombuffer(buffer.get_obj(), dtype=dt).reshape(
                    nrow,ncol
                )
                tmp = tmp.astype(dt)
                np.copyto(image, tmp)

        except zmq.error.Again:
            pass

def update():
    levels = hist.getLevels()
    # levels2 = hist2.getLevels()
    with buffer.get_lock():
        image = np.frombuffer(buffer.get_obj(), dtype=dt).reshape(
                nrow,ncol
            )
        img.setImage(image, autoRange = False, autoLevels = False, autoHistogramRange = False)



def imageHoverEvent(event):
    if event.isExit():
        p1.setTitle("")
        return
    pos = event.pos()
    i, j = pos.y(), pos.x()
    i = int(np.clip(i, 0, data.shape[0] - 1))
    j = int(np.clip(j, 0, data.shape[1] - 1))
    val = data[i, j]
    ppos = img.mapToParent(pos)
    x, y = ppos.x(), ppos.y()
    p1.setTitle("pos: (%0.1f, %0.1f)  pixel: (%d, %d)  value: %.3g" % (x, y, i, j, val))

img.hoverEvent = imageHoverEvent

#Timer to update the image, this is separate from the receiving
#We could check and only update if we have a new image...
timer = QtCore.QTimer()
timer.timeout.connect(update)
timer.start(100)

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--convert', action='store_true')
    args = parser.parse_args()

    #This flag is used to inform the reader when to exit
    exit_flag = mp.Value(ctypes.c_bool)
    exit_flag.value = False 

    #This has to match dt )
    buffer = mp.Array(ctypes.c_float, nrow*ncol)
    reader = mp.Process(target=read_stream, args=[buffer, exit_flag,])
    reader.start()

    #Run the event loop for the GUI 
    pg.exec()

    #When the window is closed tell the reader loop to exit
    exit_flag.value = True
    reader.join()