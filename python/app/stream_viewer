#!/usr/bin/env python
"""
Stand alone stream viewer uses pyqtgraph to display the images.
Should not depend on anything else in reuss.


"""


import argparse
import ctypes
import multiprocessing as mp
import numpy as np
import zmq


import pyqtgraph as pg
from pyqtgraph.Qt import QtCore, QtGui, QtWidgets
from pyqtgraph.dockarea import DockArea, Dock

#Configuration
nrow = 512
ncol = 1024
dt = np.float32
timeout_ms = 100


pg.setConfigOptions(imageAxisOrder='row-major')
pg.mkQApp()

app = pg.mkQApp("DockArea Example")
win = QtWidgets.QMainWindow()
win.setWindowTitle('Jungfrau')
area = DockArea()
win.setCentralWidget(area)
win.resize(1000,500)
d1 = Dock("Image", size=(1000, 250))
area.addDock(d1, 'top')
w1 = pg.GraphicsLayoutWidget()
p1 = w1.addPlot(title="")
d1.addWidget(w1)
img = pg.ImageItem()
p1.addItem(img)
hist = pg.HistogramLUTItem()
hist.setImageItem(img)
hist.gradient.loadPreset('viridis')
w1.addItem(hist)


#Set some initial data
data = np.random.rand(nrow,ncol)
img.setImage(data, autoRange = False, autoLevels = False, autoHistogramRange = False)

win.resize(900, 800)
win.show()
p1.setAspectLocked(True)
hist.setLevels(0,255)


def read_stream(buffer, exit_flag, endpoint):
    """
    Read images from the receiver zmq stream. Reuss sends
    multipart messages with [int64 frame_nr][float32 image]
    No data on size of image is provided so you have to set
    this in the configuration on top.
    """

    n_frames = 2
    context = zmq.Context()
    socket = context.socket(zmq.SUB)
    socket.setsockopt(zmq.RCVTIMEO, timeout_ms)
    socket.setsockopt(zmq.RCVHWM, n_frames)
    socket.setsockopt(zmq.RCVBUF, n_frames*1024**2*np.dtype(dt).itemsize)
    
    socket.connect(endpoint)
    socket.setsockopt(zmq.SUBSCRIBE, b"")

    while not exit_flag.value:
        #Try to read an image, if timeout then try again
        try:
            msgs = socket.recv_multipart()
            frame_nr = np.frombuffer(msgs[0], dtype = np.int64)[0]
            tmp = np.frombuffer(msgs[1], dtype = np.float32).reshape(512, 1024)
            with buffer.get_lock():
                image = np.frombuffer(buffer.get_obj(), dtype=dt).reshape(
                    nrow,ncol
                )
                tmp = tmp.astype(dt)
                np.copyto(image, tmp)
            global data
            np.copyto(data, tmp)
        except zmq.error.Again:
            pass

def update():
    with buffer.get_lock():
        image = np.frombuffer(buffer.get_obj(), dtype=dt).reshape(
                nrow,ncol
            )
        
        img.setImage(image, autoRange = False, autoLevels = False, autoHistogramRange = False)



def imageHoverEvent(event):
    global data
    if event.isExit():
        p1.setTitle("")
        return
    pos = event.pos()
    i, j = pos.y(), pos.x()
    i = int(np.clip(i, 0, data.shape[0] - 1))
    j = int(np.clip(j, 0, data.shape[1] - 1))
    
    val = data[i, j]
    ppos = img.mapToParent(pos)
    x, y = ppos.x(), ppos.y()
    p1.setTitle("pos: (%0.1f, %0.1f)  pixel: (%d, %d)  value: %.3g" % (x, y, i, j, val))

img.hoverEvent = imageHoverEvent

#Timer to update the image, this is separate from the receiving
#We could check and only update if we have a new image...
timer = QtCore.QTimer()
timer.timeout.connect(update)
timer.start(10)

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-s', '--stream', type=str, default="tcp://localhost:4545", help="zmq stream")
    args = parser.parse_args()

    #This flag is used to inform the reader when to exit
    exit_flag = mp.Value(ctypes.c_bool)
    exit_flag.value = False 

    #This has to match dt )
    buffer = mp.Array(ctypes.c_float, nrow*ncol)
    reader = mp.Process(target=read_stream, args=[buffer, exit_flag,args.stream])
    reader.start()

    #Run the event loop for the GUI 
    pg.exec()

    #When the window is closed tell the reader loop to exit
    exit_flag.value = True
    reader.join()